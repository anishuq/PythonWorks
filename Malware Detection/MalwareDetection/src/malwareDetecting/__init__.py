'''
Created on 15th April, 2010.

@author: A. M. Anisul Huq (82372J)
Sources:
http://www.codebreakers-journal.com/downloads/recon2006/recon2006_Carrera_Static_Analysis.pdf
http://code.google.com/p/pefile/wiki/UsageExamples
https://www.blackhat.com/presentations/bh-usa-07/Carrera/Presentation/bh-usa-07-carrera.pdf
Code is written in Python2
'''
import os, sys, pefile, peutils, pydasm, math;

def calculateEntropy(sectionInput):
    entropy = 0

    for x in range(256):
        p_x = float(sectionInput.count(chr(x)))/len(sectionInput);
        if p_x > 0:
            entropy += - p_x*math.log(p_x, 2);
                
    return entropy;              


def deObfuscation(pathPlusFilename,signatureDB,fileName):

    if (pathPlusFilename == None):
        print "ERROR: filename NOT specified!"
    #else:
    #    print pathPlusFilename;

    pe = pefile.PE(pathPlusFilename, fast_load=True);

    matches = signatureDB.match_all(pe, ep_only=True);
    
    if(matches != None):
        print matches;
    #### Read each section and determine if PACKING is present or not (start).
    
    for section in pe.sections:
        sectionName = section.Name;
        if (sectionName.find("UPX")!=-1):
            print sectionName," of ",fileName," is packed with UPX!";
        elif (sectionName.find("aspack")!=-1):
            print sectionName," of ",fileName," is packed with ASPACK!";
        else: calculateEntropy(section.data);    

    #### Read each section and determine if PACKING is present or not (end).
    
    #shadowEntryPoint is the Relative Virtual Address (rva) not offset.
    
    #At first, I fetched the entry point address and then retrieved the immediate
    #100 bytes after the entry point and then looped through it: 
    shadowEntryPoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint;
    ep_ava = shadowEntryPoint + pe.OPTIONAL_HEADER.ImageBase;
    hundredByteData = pe.get_memory_mapped_image()[shadowEntryPoint:shadowEntryPoint+100];
    
    offsetRelativeVirtualAddress = 0;
    encrypterValue = 0;
    dw = 0;
    jumpDestinationAddress = 0;
    
    ## Here we find the actual entry point by finding the suspicious JMP instruction.
    # While loop (start)
    while (offsetRelativeVirtualAddress < len(hundredByteData)):
        i = pydasm.get_instruction(hundredByteData[offsetRelativeVirtualAddress:], pydasm.MODE_32);
        
       
       # This is the opcode for "MOV BL, someHexValue (e.g. 26h in bad1.exe)", 
       # retrieve the hex value so that is used for encryption. 
        if (pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava+offsetRelativeVirtualAddress).find("mov bl")!=-1):
            encrypterValue = int(i.op2.immediate);
            
        elif (pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava+offsetRelativeVirtualAddress).find("mov esi")!=-1):
            dw = int(i.op2.immediate);

       # Stop the loop when a suspicious JMP instruction is found.
        elif ( (pydasm.get_instruction_string(i, pydasm.FORMAT_INTEL, ep_ava+offsetRelativeVirtualAddress).find("jmp")!=-1) & (i.op1.immediate < 0)):
            jumpDestinationAddress = int(shadowEntryPoint+(offsetRelativeVirtualAddress+i.length)+i.op1.immediate)
            break;

        offsetRelativeVirtualAddress = offsetRelativeVirtualAddress + i.length;
    # While loop (end)
  
    malwareSignature="";
    startOfTextSection = pe.get_physical_by_rva(dw - pe.OPTIONAL_HEADER.ImageBase);
    # "dw - pe.OPTIONAL_HEADER.ImageBase" is the offset of the .text section (here 1000h).
    
    realEntryPoint = pe.get_physical_by_rva(jumpDestinationAddress);
 
    while (startOfTextSection < realEntryPoint): 
        doubleWordData = pe.get_data_from_dword(pe.get_dword_from_offset(startOfTextSection));
        for i in range(0, len(doubleWordData)):
            malwareSignature = malwareSignature + chr(encrypterValue ^ int(doubleWordData[i].encode('hex'), 16));
            encrypterValue = int(doubleWordData[i].encode('hex'), 16);
            i = i + 1;
        startOfTextSection = startOfTextSection + 4;

    return malwareSignature;
    
################################


def main():
    pathToFiles = os.getcwd() + "/testFiles/";
    signatureDB=peutils.SignatureDatabase(pathToFiles+"userDB.txt");
    for fileNames in os.listdir(pathToFiles):
        if (fileNames.find(".exe")!=-1):
            signatureFound=deObfuscation(pathToFiles+fileNames,signatureDB,fileNames);
            if(signatureFound.find("You must detect this file")!=-1):
                print fileNames," is a malware!!!!";
            elif(signatureFound.find("You must *NOT* detect this file")!=-1):
                print fileNames," is harmless.";
    
    
        
if __name__ == '__main__':
    sys.exit(main());
        
        
            